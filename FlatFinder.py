# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FlatFinder
                                 A QGIS plugin
 This plugin seeks to help when searching for an appartment
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-11-23
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Kononow Stephan, Palka Nikolaus, Seisenbacher Daniel
        email                : a12002194@unet.univie.ac.at
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import sys

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis.core import QgsVectorLayer, QgsProject, QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsRasterBandStats, QgsRasterLayer

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .FlatFinder_dialog import FlatFinderDialog
import os.path

class FlatFinder:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'FlatFinder_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&FlatFinder')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('FlatFinder', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/FlatFinder/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'FlatFinder'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&FlatFinder'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = FlatFinderDialog()

        self.dlg.show()
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            print("---------------------------------------")
            print("Running FlatFinder...")

            data = {
                "socialLayer": {"combobox": self.dlg.mMapLayerComboBox_6, "slider": self.dlg.slider1},
                "leisureLayer": {"combobox": self.dlg.mMapLayerComboBox_4, "slider": self.dlg.slider4},
                "publictransportLayer": {"combobox": self.dlg.mMapLayerComboBox_3, "slider": self.dlg.slider3},
                "educationLayer": {"combobox": self.dlg.qgsMapLayerComboBox_2, "slider": self.dlg.slider2},
            }

            # get the raster size metric
            pixel_size = self.dlg.spinBox.value()

            # get current extent
            if self.dlg.mMapLayerComboBox.currentLayer() is None:
                extent = self.iface.mapCanvas().extent()
            else:
                extent = self.dlg.mMapLayerComboBox.currentLayer().extent()

            # reproject the extent coordinates if not epsg 4326
            extent_dict, widened_extent_dict = reproject_extent(extent)

            # download OSM data based on extent
            for key, value in data.items():
                current_layer = value['combobox'].currentLayer()

                if current_layer is None:
                    # get osm Features
                    vlayer = get_osm_features(
                        layer=key,
                        extent_string=f"{widened_extent_dict["ll_lat"]},{widened_extent_dict["ll_lon"]},{widened_extent_dict["ur_lat"]},{widened_extent_dict["ur_lon"]}"
                    )
                else:
                    vlayer = current_layer

                # assure all layers use pseudomercator (epsg: 3857)
                if vlayer.crs().authid() != 'EPSG:3857':
                    vlayer = reproject_vlayer(vlayer)


                # rasterize for the nearest neighbour analysis
                rlayer = rasterize_vlayer(vlayer["OUTPUT"], pixel_size, widened_extent_dict)

                if key == "leisureLayer" and current_layer is None:
                    rlayer = sieve_raster(rlayer["OUTPUT"], pixel_size)

                rlayer = nearest_neighbour(rlayer["OUTPUT"])
                rlayer = clip_to_extent(rlayer["OUTPUT"], extent_dict)
                rlayer = normalize_rlayer(rlayer["OUTPUT"], type_=key)


                # add final things to the dict - the output path of the normalized raster and the weight
                data[key]["OUTPUT"] = QgsRasterLayer(rlayer["OUTPUT"], key)
                data[key]["WEIGHT"] = data[key]["slider"].value()

            normalize_results_bool = self.dlg.checkBox.isChecked()
            rlayer = calculate_index(data, normalize_results_bool)

            # make the layer stylish ;)
            style_path = os.path.join(self.plugin_dir, "result_style.qml")
            set_style(rlayer["OUTPUT"], style_path)
            print("FlatFinder finished...")
            print("---------------------------------------")

def reproject_extent(extent):
    # Get the source CRS
    source_crs = QgsProject.instance().crs()
    if hasattr(extent, 'sourceCrs'):
        source_crs = extent.sourceCrs

    # Define the target CRS (EPSG:4326)
    target_crs = QgsCoordinateReferenceSystem("EPSG:4326")
    transform = QgsCoordinateTransform(source_crs, target_crs, QgsProject.instance())

    # Transform the extent coordinates
    min_point = transform.transform(extent.xMinimum(), extent.yMinimum())
    max_point = transform.transform(extent.xMaximum(), extent.yMaximum())

    # Return the reprojected extent as a dictionary
    extent_dict = {
        "ll_lon": min_point.x(),
        "ll_lat": min_point.y(),
        "ur_lon": max_point.x(),
        "ur_lat": max_point.y()
    }

    # to account for edge effects, the osm data needs to be downloaded for a bigger extent
    widened_extent_dict = {
        "ll_lon": min_point.x()-((max_point.x() - min_point.x())/2),
        "ll_lat": min_point.y()-((max_point.y() - min_point.y())/2),
        "ur_lon": max_point.x()+((max_point.x() - min_point.x())/2),
        "ur_lat": max_point.y()+((max_point.y() - min_point.y())/2)
    }

    # print(extent_dict)
    # print(widened_extent_dict)
    return extent_dict, widened_extent_dict

def get_osm_features(layer, extent_string):
    import processing

    if layer == "leisureLayer":
        # run the file downloader for the leisureLayer, with the specified QUICKOSM query
        osm_output = processing.run("native:filedownloader", {
            'URL': f"https://overpass-api.de/api/interpreter?data=[out:xml] [timeout:25];%0A(%0A node[%22landuse%22%3D%22grass%22]( {extent_string});%0A node[%22landuse%22%3D%22forest%22]( {extent_string});%0A node[%22leisure%22%3D%22park%22]( {extent_string});%0A way[%22landuse%22%3D%22grass%22]( {extent_string});%0A way[%22landuse%22%3D%22forest%22]( {extent_string});%0A way[%22leisure%22%3D%22park%22]( {extent_string});%0A relation[%22landuse%22%3D%22grass%22]( {extent_string});%0A relation[%22landuse%22%3D%22forest%22]( {extent_string});%0A relation[%22leisure%22%3D%22park%22]( {extent_string});%0A);%0A(._;%3E;);%0Aout body;&info=QgisQuickOSMPlugin",
            'METHOD': 0, 'DATA': '', 'OUTPUT': 'TEMPORARY_OUTPUT'})
        osm_output = osm_output["OUTPUT"]

        # Load the data as a vector layer
        data_source = f"{osm_output}|layername=multipolygons"
        vlayer = QgsVectorLayer(data_source, "leisure", "ogr")

    elif layer == "educationLayer":
        # run the file downloader for the educationLayer, with the specified QUICKOSM query
        osm_output = processing.run("native:filedownloader", {
            'URL': f"https://overpass-api.de/api/interpreter?data=[out:xml] [timeout:25];%0A(%0A node[%22amenity%22%3D%22university%22]( {extent_string});%0A node[%22amenity%22%3D%22school%22]( {extent_string});%0A way[%22amenity%22%3D%22university%22]( {extent_string});%0A way[%22amenity%22%3D%22school%22]( {extent_string});%0A relation[%22amenity%22%3D%22university%22]( {extent_string});%0A relation[%22amenity%22%3D%22school%22]( {extent_string});%0A);%0A(._;%3E;);%0Aout body;&info=QgisQuickOSMPlugin",
            'METHOD': 0, 'DATA': '', 'OUTPUT': 'TEMPORARY_OUTPUT'})
        osm_output = osm_output["OUTPUT"]

        # Load the data as a vector layer
        data_source = f"{osm_output}|layername=points"
        vlayer = QgsVectorLayer(data_source, "education", "ogr")

    elif layer == "publictransportLayer":
        # Todo: Improve query
        # run the file downloader for the publictransportLayer, with the specified QUICKOSM query
        osm_output = processing.run("native:filedownloader", {
            'URL': f"https://overpass-api.de/api/interpreter?data=[out:xml] [timeout:25];%0A(%0A node[%22public_transport%22%3D%22station%22]( {extent_string});%0A node[%22amenity%22%3D%22bus_station%22]( {extent_string});%0A way[%22public_transport%22%3D%22station%22]( {extent_string});%0A way[%22amenity%22%3D%22bus_station%22]( {extent_string});%0A relation[%22public_transport%22%3D%22station%22]( {extent_string});%0A relation[%22amenity%22%3D%22bus_station%22]( {extent_string});%0A);%0A(._;%3E;);%0Aout body;&info=QgisQuickOSMPlugin",
            'METHOD': 0, 'DATA': '', 'OUTPUT': 'TEMPORARY_OUTPUT'})
        osm_output = osm_output["OUTPUT"]

        # Load the data as a vector layer
        data_source = f"{osm_output}|layername=points"
        vlayer = QgsVectorLayer(data_source, "publictransportation", "ogr")

    elif layer == "socialLayer":
        # run the file downloader for the socialLayer, with the specified QUICKOSM query
        osm_output = processing.run("native:filedownloader", {
            'URL': f"https://overpass-api.de/api/interpreter?data=[out:xml] [timeout:25];%0A(%0A node[%22amenity%22%3D%22cafe%22]( {extent_string});%0A node[%22amenity%22%3D%22restaurant%22]( {extent_string});%0A node[%22amenity%22%3D%22bar%22]( {extent_string});%0A node[%22amenity%22%3D%22nightclub%22]( {extent_string});%0A way[%22amenity%22%3D%22cafe%22]( {extent_string});%0A way[%22amenity%22%3D%22restaurant%22]( {extent_string});%0A way[%22amenity%22%3D%22bar%22]( {extent_string});%0A way[%22amenity%22%3D%22nightclub%22]( {extent_string});%0A relation[%22amenity%22%3D%22cafe%22]( {extent_string});%0A relation[%22amenity%22%3D%22restaurant%22]( {extent_string});%0A relation[%22amenity%22%3D%22bar%22]( {extent_string});%0A relation[%22amenity%22%3D%22nightclub%22]( {extent_string});%0A);%0A(._;%3E;);%0Aout body;&info=QgisQuickOSMPlugin",
            'METHOD': 0, 'DATA': '', 'OUTPUT': 'TEMPORARY_OUTPUT'})
        osm_output = osm_output["OUTPUT"]

        # Load the data as a vector layer
        data_source = f"{osm_output}|layername=points"
        vlayer = QgsVectorLayer(data_source, "social", "ogr")

    else:
        print("ERROR - layer not found")

    # check validity
    if not vlayer.isValid():
        print("Layer failed to load!")
    else:
        QgsProject.instance().addMapLayer(vlayer)
    return vlayer

def reproject_vlayer(vlayer):
    import processing

    # reproject the layer to pseudo-mercator
    vlayer = processing.run("native:reprojectlayer", {
        'INPUT': vlayer,
        'TARGET_CRS': QgsCoordinateReferenceSystem('EPSG:3857'), 'CONVERT_CURVED_GEOMETRIES': False,
        'OPERATION': '+proj=pipeline +step +proj=unitconvert +xy_in=deg +xy_out=rad +step +proj=webmerc +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84',
        'OUTPUT': 'TEMPORARY_OUTPUT'})

    return vlayer

def rasterize_vlayer(vlayer, pixel_size, extent_dict):
    import processing

    # rasterize the layer
    rlayer = processing.run("gdal:rasterize", {
        'INPUT': vlayer,
        'FIELD': '', 'BURN': 99, 'USE_Z': False, 'UNITS': 1,
        'WIDTH': pixel_size, 'HEIGHT': pixel_size,
        'EXTENT': f'{extent_dict["ll_lon"]},{extent_dict["ur_lon"]},{extent_dict["ll_lat"]},{extent_dict["ur_lat"]} [EPSG:4326]',
        'NODATA': 0,
        'OPTIONS': '', 'DATA_TYPE': 0, 'INIT': 1, 'INVERT': False, 'EXTRA': '', 'OUTPUT': 'TEMPORARY_OUTPUT'})
    return rlayer

def sieve_raster(rlayer, pixel_size):
    import math
    import processing
    nr_of_px_to_ignore = math.ceil(pixel_size/12.5)

    rlayer = processing.run("gdal:sieve", {
        'INPUT': rlayer,
        'THRESHOLD': nr_of_px_to_ignore,
        'EIGHT_CONNECTEDNESS': False,
        'NO_MASK': False, 'MASK_LAYER': None, 'EXTRA': '',
        'OUTPUT': 'TEMPORARY_OUTPUT'})

    return rlayer

def nearest_neighbour(rlayer):
    import processing
    rlayer = processing.run("gdal:proximity", {
        'INPUT': rlayer,
        'BAND': 1, 'VALUES': '99', 'UNITS': 0, 'MAX_DISTANCE': 0, 'REPLACE': 0, 'NODATA': 0, 'OPTIONS': '', 'EXTRA': '',
        'DATA_TYPE': 5, 'OUTPUT': 'TEMPORARY_OUTPUT'})
    return rlayer

def clip_to_extent(rlayer, extent_dict):
    import processing

    # as a bigger extent was used to account for edge effects, we can now return to the original extent
    rlayer = processing.run("gdal:cliprasterbyextent", {
        'INPUT': rlayer,
        'PROJWIN': f'{extent_dict["ll_lon"]},{extent_dict["ur_lon"]},{extent_dict["ll_lat"]},{extent_dict["ur_lat"]} [EPSG:4326]',
        'OVERCRS': False, 'NODATA': None, 'OPTIONS': '', 'DATA_TYPE': 0, 'EXTRA': '', 'OUTPUT': 'TEMPORARY_OUTPUT'})

    return rlayer

def normalize_rlayer(rlayer, type_):
    import processing

    print("start normalizing raster...")
    rlayer = QgsRasterLayer(rlayer, type_)
    provider = rlayer.dataProvider()

    # get statistics for band 1
    band = 1
    stats = provider.bandStatistics(band, QgsRasterBandStats.All)
    max_value = stats.maximumValue

    # build normalization expression
    expression = f'100 - (100/{max_value}*"{type_}@1")'

    # normalize raster
    rlayer = processing.run("native:rastercalc", {
        'LAYERS': [rlayer],
        'EXPRESSION': expression, 'EXTENT': None, 'CELL_SIZE': None, 'CRS': None,
        'OUTPUT': 'TEMPORARY_OUTPUT'})

    return rlayer

def calculate_index(data, normalize_results_bool):
    import processing
    print("start calculating the index ...")

    # Build expression (Adding all the weighted raster cells) and dividing
    base_string = '('
    for key, value in data.items():
        new_string = f'"{key}@1"*({value["WEIGHT"]}/100)+'
        base_string += new_string
    expr_string = base_string[:-1] + ')'

    if not normalize_results_bool:
        # Display directly if no normalization has been chosen
        rlayer = processing.runAndLoadResults("native:rastercalc", {
            'LAYERS': [value["OUTPUT"] for value in data.values()],
            'EXPRESSION': expr_string,
            'EXTENT': None, 'CELL_SIZE': None, 'CRS': None, 'OUTPUT': 'TEMPORARY_OUTPUT'})

    else:

        # don't display if normalization has been chosen
        rlayer = processing.run("native:rastercalc", {
            'LAYERS': [value["OUTPUT"] for value in data.values()],
            'EXPRESSION': expr_string,
            'EXTENT': None, 'CELL_SIZE': None, 'CRS': None, 'OUTPUT': 'TEMPORARY_OUTPUT'})

        # get the max value for normalization
        rlayer = QgsRasterLayer(rlayer["OUTPUT"], "unnormalized raster")
        provider = rlayer.dataProvider()

        # get statistics for band 1
        band = 1
        stats = provider.bandStatistics(band, QgsRasterBandStats.All)
        max_value = stats.maximumValue
        min_value = stats.minimumValue

        # build normalization expression
        expression = f'("unnormalized raster@1"-{min_value})/({max_value}-{min_value})*100'

        rlayer = processing.runAndLoadResults("native:rastercalc", {'LAYERS': [rlayer],
                                             'EXPRESSION': expression, 'EXTENT': None,
                                             'CELL_SIZE': None, 'CRS': None, 'OUTPUT': 'TEMPORARY_OUTPUT'})

    return rlayer

def set_style(rlayer, style_path):
    import processing
    processing.run("native:setlayerstyle", {
        'INPUT': rlayer,
        'STYLE': style_path})
    pass
